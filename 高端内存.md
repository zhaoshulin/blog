#高端内存

----------
##Why Highmem

在32位的x86架构下，Kernel把4GB的虚拟内存地址空间划分为两部分：

- 1GB内核空间
- 3GB用户空间

内核必须可以把内存条上所有的物理内存映射到内核空间上，这样内核就可以：

- 从Kernel空间中，可以直接访问任意的内存（简单快速）
- 内核中的某个对象可以使用指针指向任意地方。可以用于：
	- track物理地址
	- 映射到物理地址，然后在访存前计算出虚拟地址
	- 使用完毕之后，撤销映射
- 就算在内核空间也可以使用大页，可以使TLB覆盖率变大，性能好

其他架构的硬件本身只能访问一部分的物理内存。32位的MIPS处理器的OS运行在512MB的物理分区上，虚拟地址和物理地址是直接映射的。要想访问其他的地址，只能通过TLB (Translation Lookaside Buffer)，而且不能同时映射所有的4GB物理地址到内核空间中。所以，high memory support 非常有必要！

##Copying with highmem
但是，许多人还是想在32位系统上使用大于1GB的物理内存。这样，Kernel必须使用以下策略：

- 当内核要访问高于896MB的内存时，这些内存空间被暂时映射到内核虚拟空间
- 内核需要频繁访问的那部分内存被放到低于896MB的内存空间里面（ZONE_NORMAL），这样一来，内核可以立即访问到
- 内核偶尔需要访问的那部分内存（比如页缓存、Process Memory、页表等）被放到高端内存ZONE\_HIGHMEN
- 系统留有一定的物理内存区域来处理DMA设备访问的那一小部分物理内存: ZONE\_DMA 和 ZONE\_DMA32
- 这些不同类型的内存区域的allocation和pageout必须要平衡

##Temporary mapping

把数据从高端内存暂时映射到内核虚拟空间，完成这个过程需要4个内核函数：

	kmap(); 长期映射，就算cpu调度了这个映射依然存在！因为使用全局块，所以在SMP系统中会出现瓶颈，所以不推荐！
	kunmap(); 
	kmap_atomic(); 无瓶颈。因为页只会被映射到特定CPU私有的某个固定地址上，所以无需锁、不能schedule进程！
	kunmap_atomic();

##Memory balancing
如果有2GB内存，一半多点的内存被映射进高端内存（ZONE\_HIGHMEM），一半少点的内存被映射进低端内存（ZONE\_NORMAL ZONE\_DMA）。

保持所有区域的大小平衡很重要！原因如下：

某个应用程序想用所有的这2GB内存，如果系统分配高端内存比分配低端内存快得多的话，该应用程序的某些需要常驻低端内存的数据就会被分配到了高端内存！理想情况下，应用程序可用的内存大小会接近2GB。

##大于4GB内存最好使用64位系统的原因
在32位系统上使用大量高端内存的3大危害如下：

1. 主要的危险：对于那些没办法在ZONE\_NORMAL存下的数据，内核就无能为力了。所以就算还有很多的高端内存，依然会出现 out of memory
2. 因为低端内存过少，内核会更加积极地回收一些内核结构（比如被缓存的inode、buffer heads等），导致性能降低
3. 所有的应用程序都无法有效使用大于3GB的内存

综上，如果内存条大于等于4GB，最好用64位CPU和64位操作系统。