#背景知识
##stat(2)中的2代表什么意思？
1. （1）：一般命令
2. （2）：系统调用
3. （3）：c库函数
4. （4）：特殊文件

有的命令可能会在不止一节中出现，比如stat既可以作为一般的shell命令，又可以作为系统调用，所以有stat(1)和stat(2)。

使用man命令的格式：

	man 2 stat
	man stat  等价于 man 1 stat

##pid和文件描述符

pid代表运行着的进程；文件描述符代表打开的文件（又称资源）。这两对都共生共灭。

已经关闭的进程没有pid；已经关闭的文件没有文件描述符。pid和文件描述符存在的目的是为了方便Kernel对进程和文件进行跟踪。

##标准流
每个进程都有三个默认已打开的资源：

1. STDIN 0
2. STDOUT 1
3. STDERR 2

#进程的资源限制

一个进程可以拥有多少个文件描述符？

查看进程的各种限制的shell命令：

	ulimit -a

修改限制的方法是：

	编辑 /etc/security/limits.conf

##软限制和硬限制

- 如果超过了软限制，会产生Errno::EMFILE异常
- 普通用户只能缩小硬限制；root可以扩大硬限制
- 硬限制控制软限制；软限制用于限制用户对资源的过度使用

#环境变量

- 所有进程都从其父进程那里继承环境变量。
- 使用环境变量比解析命令行选项快
- ENV并不是hash，虽然它的实现方式是键值对

#进程参数ARGV

- argv: argument vector
- argv数组保存了在命令行中传递给当前进程的参数
- 解析命令行选项的过程：在shell读取ARGV数组中的内容之前，先将其修改为命令行选项，这样就实现了运行时更改命令选项

#进程退出码

##exit

	exit 顺利退出码0
	exit 22 自定义退出码22

当Kernel调用exit之前，会先调用at\_exit：
	
	at_exit{...}
	exit

##exit!

exit!与exit的两个区别：

1. 默认的退出码是1
2. 在退出之前不会调用at\_exit

##abort

- abort提供了从错误进程中退出的通用方法
- 默认退出码是1
- abort "..." 会在退出之前，把打印消息加到STDERR上
- 退出之前, abort会调用at\_exit

注意下面代码的执行顺序：
	
	at_exit{puts 'Something in at_exit.'}
	abort "Something in abort."

输出：

	Something in abort.
	Something in at_exit.

##raise

- raise不会立刻结束进程，只是抛出一个异常，该异常会沿着调用栈向上传递，幸运的话会得到处理。但是如果没有代码对其进行处理，那么这个未处理的异常只好终结该进程
- 退出码是1
- 退出之前会调用at\_exit，并向STDERR打印异常信息和回溯

#进程衍生

##fork

子进程从父进程继承来的两样东西：
1. memory中的所有内容
2. 父进程已打开的文件描述符

- 子进程可以任意修改memory的副本，而不会对父进程产生任何影响
- fork返回两次：
		1. 父进程返回一次，返回子进程pid
		2. 子进程返回一次，返回0

##fork炸弹

如果你有2GB内存，一个使用了500MB内存的进程fork 4次之后，就耗尽了所有的内存。

##多核编程

如果你有2个CPU，fork了一个新进程，那么有可能父进程和子进程分别运行在不同的CPU上，实现多核并发。

#孤儿进程

- 父进程结束之后，子进程安然无恙继续照常运行
- 守护进程属于孤儿进程，原因是为了可以长期运行，它不需要一个父亲来影响它长期运行

#写时复制 CoW （Copy on Write）

- fork创建了一个与父进程一模一样的子进程，子进程包含了父进程在memory中的一切
- 实际上，一开始，父子进程共享内存中的数据；直到某一个进程需要写数据，那时候才会进行内存复制，以保持父子进程的隔离
- 进一步优化：只需要复制必需的那一小部分数据（即二者有差异的那部分数据），其他的大部分数据依然可以共享

#进程等待

- wait() 父进程有多个子进程，任意一个子进程退出之后，父进程就退出，返回退出的那个子进程pid
- waitpid(pid) 父进程等待他的那个特定的孩子（由pid指定）退出之后，就会退出
- 如果有多个孩子死亡，Kernel会依次把死亡孩子的信息加入队列，以便确保所有的孩子死亡都可以被父亲处理到

#僵尸进程

- 僵尸进程的产生：Kernel把所有死亡的孩子信息加入队列（暂时停尸房），等待父进程来读取处理这些信息。但是父进程就不来读取，Kernel只好一直保存这这些无火化的尸体，即僵尸。
- ps显示的状态为"z"或者"Z+"：表示这是一个僵尸进程

#信号

- CHLD信号：Kernel通知父进程他的孩子死了
- 进程A发送信号 ---> Kernel ---> 进程B接收到信号
- SIGKILL和SIGSTOP信号不能被捕获、阻塞或忽略
- 用户进程可以自定义的两个信号是：SIGUSR1和SIGUSR2
- 管道是单向的；socket是双向的

#守护进程

- 守护进程是在后台运行的进程，不受终端用户的控制，web服务器就是一个例子
- 第一个进程是init进程，它的pid是1；父亲（其实没有）的pid是0
- 孤儿的ppid都是1 （init）
- 任何进程都可以变成守护进程
- 父子进程同属于一个进程组，这解释了这样一个现象：使用Ctrl-C会不仅杀死了父亲，儿子们也都被杀死了。这是因为：发送给进程组组长的Kill信号被转发给了该进程组中的所有进程，实现了“连坐”
- 多个进程组的集合叫做会话组，发送给会话组组长的信号会被转发给所有的进程组；然后会被进一步转发给所有的进程

**TODO**：

1. 如何创建一个守护进程？
2. 如何终止这个守护进程？

#生成终端进程

## exec

- exec用另一个进程来代替本身
- exec不会关闭文件描述符；不会清理memory
- 如果把字符串传递给exec：会再启动一个shell解释进程，进行解释
- 如果把数组传递给exec：会跳过shell，直接把该数组作为新进程的ARGV

##fork + exec

1. 先fork，有了父亲和儿子；
2. 再exec，把儿子更换为我需要的shell命令，狸猫换太子

##spawn

1. 孩子获得父亲的所有文件描述符副本
2. 但是！孩子不会得到父亲的memory内容副本
3. 所以，spawn比fork更快；但是不灵活
























