# 系统启动

----------
启动（bootstrap）依赖体系结构，x86下：

- 载入部分OS到memory
- 初始化内核数据结构
- 创建一些用户进程
- 把控制权转交给某个进程

##史前时代：BIOS

1. 启动
2. 在CPU的某个引脚上产生reset信号
3. 执行在物理地址0xfffffff0处的代码
4. 上述地址被映射到保存在ROM中的BIOS程序那里
5. BIOS实现大部分的系统调用

注意：

- BIOS必须运行在实模式下
- Linux一旦进入保护模式，就不再使用BIOS
- 因为：实模式下的物理地址= seg*16 + off
- 所以：实模式下不需要GDT、LDT、页表的帮助来把逻辑地址->物理地址
- 所以：GDT、LDT、页表的初始化是在实模式下完成的

**！！！BIOS启动过程！！！**：

1. 上电自检：建立几个表来描述硬件设备
2. 初始化硬件设备：最后会显示所安装的所有的PCI设备
3. 找到引导扇区：根据BIOS的设置，依次（比如：u盘 CDROM disk的顺序）访问外部存储的引导扇区，搜索一个OS来启动
4. copy引导扇区到RAM的0x00007c00位置，跳到此位置，运行OS

##远古时代：boot loader
- 作用：BIOS调用boot loader ，copy引导扇区到RAM的0x00007c00位置。
- MBR：硬盘的第一个扇区，包含：
	- 分区表：起止扇区 + OS类型
	- LILO或者GRUB程序：用于加载引导扇区
	
- LILO引导装入程序的执行过程：
	1. 调用一个BIOS过程，显示 “ Loading ”
	2. 调用一个BIOS过程，装入setup代码
	3. 调用一个BIOS过程，装载其他的内核映像
	4. 跳转到setup

##中世纪：setup()函数
- 虽然BIOS已经初始化了大部分的硬件，但是Linux并不依赖BIOS，而是以自己的方式重新初始化设备以增强可移植性和健壮性
- 所以：setup的作用是：重新初始化硬件设备；并为Kernel的执行建立环境
- setup执行步骤：
	1. 初始化检测到的硬件设备
	2. 建立临时的IDT和GDT
	3. 屏蔽除了IRQ2的所有中断（因为IRQ2是两个PIC之间的级联中断）
	4. 实模式 -> 保护模式、
	5. 跳转到startup_32()

##文艺复兴时期：startup_32()函数

1. 第一个startup_32()：解压内核映像
2. 第二个startup_32()：为进程0建立起执行环境
3. 跳转到start_kernel()

##现代：startup_32()函数
- 作用：完成内核的初始化
- 步骤：
	1. 初始化调度程序
	2. 初始化内存管理区
	3. 初始化伙伴系统分配
	4. 初始化IDT
	5. 初始化软中断
	6. 初始化日期和时间
	7. 初始化slab分配器
	8. 初始化CPU时钟频率
	9. 创建进程1（即init）
	10. start x 提示登陆
