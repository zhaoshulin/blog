#页高速缓存

----------
三种磁盘cache：

1. 页cache：cache数据页
2. 目录项cache：cache描述文件系统路径名的目录项对象
3. 索引节点cache：cache描述磁盘索引节点的索引节点对象

##page cache
- 如果页不在cache中，新页就会被追加到cache中，然后用disk中的内容填充这个新页
- 延迟的写操作
- O_DIRECT标志位被置位 => 会绕过page cache，使用用户态地址空间的缓冲区

### address_space对象
- 如何在page cache中查找到页？
	1. mapping：指向owner的索引节点的address_space
	2. index：表示在owner的地址空间中 以页为单位的偏移
- backing\_dev\_info结构嵌入在块设备的请求队列描述符中
- private_list链表用以收集脏页；刷新的时候也同时刷新该链表
- 自旋锁保护多处理器系统中的间接块链表
- a_ops：定义了对页进行的所有操作

###基树
- 基树的目的是：快速查找cache
- 每个address_space对象对应一棵基树；address_space中的page_tree对是基树树根
- 基树的叶子节点指向页描述符
- 查找过程简述：给定一个页索引 ---> 基树中的路径 ---> 页描述符(or not in radix_tree)

###page cache的处理函数

1. 查找页：自旋锁锁基树；增加该页的使用计数器；返回该页地址
2. lock\_page：如果该页已上锁，阻塞，死等（死缠烂打的游手好闲之辈）
3. try\_lock\_page：如果该页已上锁，不阻塞，返回错误代码（不在一棵树上吊死的薄情男）
4. 增加页：preload禁用内核抢占并确保内存还够用；自旋锁锁基树；因为新页无效所以要锁住该页；preload\_end重新启用内核抢占
5. 更新页：
	1. 如果该页不在cache中：分配新页；插入到inactive lru链表
	2. mark page accessed 增加访问热度
	3. 如果PG\_uptodate标志为0，磁盘 ---> cache

###基树的标记
为了能够快速找到脏页和写回页，增加PG\_dirty PG\_writeback：

1. 中间节点的脏标记为0，说明其子树中的所有页描述符都是不脏的；
2. 中间节点的写回标记为0，说明其子树中的所有页描述符都是不需写回的
3. 清除标记的过程：
	1. 根 ---> 叶子：建立路径
	2. 叶子 ---> 根：清除标记
4. 所以，radix\_tree\_tagged()只需要检查第一层的标记即可！

##磁盘块 ---> cache


