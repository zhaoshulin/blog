#页高速缓存

----------
三种磁盘cache：

1. 页cache：cache数据页
2. 目录项cache：cache描述文件系统路径名的目录项对象
3. 索引节点cache：cache描述磁盘索引节点的索引节点对象

##page cache
- 如果页不在cache中，新页就会被追加到cache中，然后用disk中的内容填充这个新页
- 延迟的写操作
- O_DIRECT标志位被置位 => 会绕过page cache，使用用户态地址空间的缓冲区

### address_space对象
- 如何在page cache中查找到页？
	1. mapping：指向owner的索引节点的address_space
	2. index：表示在owner的地址空间中 以页为单位的偏移
- backing\_dev\_info结构嵌入在块设备的请求队列描述符中
- private_list链表用以收集脏页；刷新的时候也同时刷新该链表
- 自旋锁保护多处理器系统中的间接块链表
- a_ops：定义了对页进行的所有操作

###基树
- 基树的目的是：快速查找cache
- 每个address_space对象对应一棵基树；address_space中的page_tree对是基树树根
- 基树的叶子节点指向页描述符
- 查找过程简述：给定一个页索引 ---> 基树中的路径 ---> 页描述符(or not in radix_tree)

###page cache的处理函数

1. 查找页：自旋锁锁基树；增加该页的使用计数器；返回该页地址
2. lock\_page：如果该页已上锁，阻塞，死等（死缠烂打的游手好闲之辈）
3. try\_lock\_page：如果该页已上锁，不阻塞，返回错误代码（不在一棵树上吊死的薄情男）
4. 增加页：preload禁用内核抢占并确保内存还够用；自旋锁锁基树；因为新页无效所以要锁住该页；preload\_end重新启用内核抢占
5. 更新页：
	1. 如果该页不在cache中：分配新页；插入到inactive lru链表
	2. mark page accessed 增加访问热度
	3. 如果PG\_uptodate标志为0，磁盘 ---> cache

###基树的标记
为了能够快速找到脏页和写回页，增加PG\_dirty PG\_writeback：

1. 中间节点的脏标记为0，说明其子树中的所有页描述符都是不脏的；
2. 中间节点的写回标记为0，说明其子树中的所有页描述符都是不需写回的
3. 清除标记的过程：
	1. 根 ---> 叶子：建立路径
	2. 叶子 ---> 根：清除标记
4. 所以，radix\_tree\_tagged()只需要检查第一层的标记即可！

##磁盘块 ---> cache
- 旧版本的内核有两种磁盘cache：
	1. page cache：缓存访问disk时生成的磁盘数据页
	2. 缓冲区cache：缓存通过VFS进行访问时生成的块

- now，缓冲区cache不存在了，变成了 buffer page，隶属于page cache

###块缓冲区和buffer head

- 内核在对块进行操作之前，会先检查buffer head
- bdev表示LUN
- blocknr表示逻辑块号

###管理buffer head
- buffer head有自己的slab分配器
- 内核控制路径希望访问块缓冲区时，count++
- 内核控制路径停止访问块缓冲区时，count--
- 只有count=0的块缓冲区才可以被回收

### 缓冲区页
- 块缓冲区放在缓冲区页中
- 只要Kernel访问一个块，就要涉及到相应的缓冲区页和buffer head
- 内核创建缓冲区页有两种情况：
		
	1. 当读写的文件页在磁盘块中不相邻的时候
	2. 当访问一个单独的磁盘块的时候：即所谓的块设备页

- 页描述符、buffer head、缓冲区之间的关系：下图是一个缓冲区页：

![](http://i.imgur.com/s3gQk4p.jpg)

- PG_writeback标志表示：该页正在被写回disk
- bh\_lrus（LRU块高速缓存）缓存的是最近被CPU访问过的buffer head
- 内核利用submit_bh()函数给通用块层一个buffer head，要求通用块层给它一个数据块

## 脏页 ---> disk



