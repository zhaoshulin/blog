#跟我一起来写一个守护进程！

----------
本文的目的：

1. 知己知彼，深入理解守护进程
2. 自己写出一个守护进程，最好能形成模板，一劳永逸

##剖析守护进程(Daemon)

###守护进程基础背景

- 守护进程是脱离于终端并在后台运行的进程
- 守护进程在系统引导时启动，在系统关闭时终止
- 守护进程之所以要脱离终端，是为了避免守护进程在执行过程中的信息在任何终端上有显示，并且守护进程也不会被任何终端所产生的终端信息所打断
- 在Linux操作系统中，在系统引导的时候会开启很多服务(service)，这些服务就是守护进程；这些服务名字的特点是最后一个字母都是d (比如inetd、ietd、httpd等)
- root 可以选择这些服务的运行级别
- 对于那些从终端键入命令产生的进程，这个终端就是它们的控制终端
- 当控制终端被关闭时，这些进程也会自动关闭
- 守护进程没有相应的控制终端，使用 $ps xj 命令可以看到守护进程的TPGID（控制终端进程组ID）=-1

###守护进程两大分类

1. 独立启动(stand_alone)守护进程：常驻内存，一直占用资源，所以响应快速，脚本都在/etc/init.d/目录下
2. 超级守护进程：xinet统一管理调度这些守护进程，多了一层管理机制，脚本都在/etc/xinetd.d/目录下

##开始创建一个守护进程！

###1. fork 弑父留子

fork创建儿子，杀掉父亲，目的：

1. 使得控制终端结束挂起，可以继续执行；Daemon在儿子中后台运行，即：在形式上脱离了控制终端
2. 使得儿子不会成为进程组的leader（因为进程组id=leader的pid，原来的组id=父亲的pid，而儿子的pid不等于父亲的pid，所以儿子肯定不是leader），保证了接下来的setsid()不会出错

		switch ( fork() ){
			case -1: exit(-1); //fork error
			case 0 : break; // 子进程后台
			default : exit(0); //父进程退出	
		}

###2.清除前朝余孽，脱胎换骨

在第一步fork的时候，儿子继承了父亲的会话期、进程组和控制终端，必须清除！

setsid()的作用：

1. 让子进程摆脱原会话的控制
2. 让子进程摆脱原进程组的控制
3. 让子进程摆脱原控制终端的控制（totally！）

		setsid();

###3. 这个儿子还有可能为父报仇，杀子留孙

此时，这个儿子已经是leader了，而leader就有权再申请一个终端（这是我们写Daemon所要极力避免的），只好再杀了它，留下它的儿子（这个孙子不是leader，无权申请终端）

		switch ( fork() ){
			case -1: exit(-1); //fork error
			case 0 : break; // 子进程后台
			default : exit(0); //父进程退出	
		}

###4. 清除从祖先继承下来的umask值

目的：后续创建的文件可以自定义权限，而不受前朝余孽的影响

		umask(0);

###5. 改变工作目录

目的：如果不这样做，有可能导致占用文件系统，使之无法卸载。一般换到 /目录下

		chdir("/");

###6. 关闭从父进程继承来的文件描述符

目的：

1. 既然已经没有控制终端了，就没必要再保留0 1 2 文件描述符了，重定向到 /dev/null，避免后续向这三个描述符进行IO发生异常
2. 当还有文件描述符在某个磁盘上时，会妨碍文件系统的卸载

		for(int fd = 0; fd < NOFILE; ++fd)
			close(fd);//关闭打开的文件描述符

		close(STDIN_FILENO);
		int fd = open("/dev/null", o_RDWR);
		if(fd != STDIN_FILENO){
			return -1;
		}//重定向STDIN

		if(dup2(STDIN_FILENO, STDOUT_FILENO) != STDOUT_FILENO)
			return -1;//重定向STDOUT

		if(dup2(STDIN_FILENO, STDERR_FILENO) != STDERR_FILENO)
			return -1;//重定向STDERR

###7. 当这个孙子死了怎么办？

当这个守护进程被杀死了，为了避免它变成僵尸，应该处理SIGCHLD信号

		signal(SIGCHLD, SIG_IGN); //ignore



