#内存管理

----------
##背景知识
- OS为每个进程在disk上创建一块虚拟地址空间，即：虚拟内存
- 虚拟内存中的一部分需要被调入内存：此时，需要硬件进行的地址转换是：虚拟地址 => 实地址
- 所谓的内存管理，管理的是：用户部分，而不是内核
- swap：在内存中移动
- 页大小相同；段大小不一定相同
- 内存管理的五点需求：
	1. 重定位 => 程序被换出之后又被换入，不必放在和以前相同的内存那里
	2. 保护：硬件实现
	3. 共享
	4. 逻辑组织
	5. 物理组织
##内存分区
###分区技术
1. 固定分区
2. 动态分区
3. 简单分页
4. 简单分段
5. 虚拟内存分页
6. 虚拟内存分段
###伙伴系统
- 洞(hole)：代表还未分配的、可用的块
- 伙伴系统处理请求一个2^i的洞，递归代码：

		void get_hole(int i){
			if(i == (MAX + 1))
				return false;

			if(i_list is empty){
				get_hole(i+1);
				split hole into buddies;
				put buddies on i_list;
			}
			get first hole on i_list;
			return true; 
		}
- 表示伙伴系统的二叉树：

![](http://i.imgur.com/z0kgA82.png)

###重定位
- 基址寄存器：进程在内存中的起始位置
- 界限寄存器：进程在内存中的终止位置
- 硬件实现的重定位：

![](http://i.imgur.com/qLB0LHU.png)

##分页
- 一个 (n+m) 位的逻辑地址：
	- n位是：页号
	- m位是：偏移量
- 逻辑地址（页号+offset） ---页表---> 物理地址（帧号+offset）

![](http://i.imgur.com/zeJbd9h.png)

	上图中：A和B是：页号

- 页表：

![](http://i.imgur.com/UAFvKn9.png)

	OS维护一个空闲帧list
- 分页：逻辑地址=>物理地址：

![](http://i.imgur.com/nVlifZD.png)

##分段
I am going to ignore you, bite me!
##加载和链接
![](http://i.imgur.com/KtRb8UF.png)

- 链接器：适用于多个模块的时候，实现了：
	- 不同模块之间的access
	- 模块对库的access
- 加载器：把程序装入内存（地址绑定，即寻址）
###加载
- 加载场景：

![](http://i.imgur.com/L1ibTMY.png)

- 加载时的寻址方式：
	- 绝对加载：某个模块总是被加载到内存的同一个位置（写代码时完成地址绑定，使用物理地址）
	- 可重定位加载：某个模块不一定被加载到内存的同一个位置（编译时完成地址绑定，使用相对地址）
	- 动态运行时加载：把物理地址的计算推迟到在运行中真正需要时（目的是：进程被换出后又被换入，希望被换入到不一样的内存位置那里，因为这样可以充分利用CPU）
- 经典的表格：

![](http://i.imgur.com/0W4qFWV.png)

###链接
- 链接器的功能：
	- 输入：好多个目标模块
	- 输出：一个完整的加载模块

![](http://i.imgur.com/4ONsxci.png)

- 上图中，一个模块对另一个模块的引用方式：
	- 链接前：使用符号引用（还没统一呢）
	- 链接后：使用位置引用（天下一统啦）
	- 这个过程叫做：解析引用
- 动态链接：把解析引用推迟到加载模块之后
	- 此时，加载模块包含一些 未解析的引用，等到真正加载才被解析
- 运行时动态链接：把解析引用推迟到真正运行时
	- 此时，有可能被调用的模块不在内存里：OS找到该模块；加载；链接